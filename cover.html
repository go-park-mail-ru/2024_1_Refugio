
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>mail: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">mail/cmd/mail/main.go (0.0%)</option>
				
				<option value="file1">mail/docs/docs.go (0.0%)</option>
				
				<option value="file2">mail/pkg/email/repo.go (89.6%)</option>
				
				<option value="file3">mail/pkg/handlers/email.go (81.3%)</option>
				
				<option value="file4">mail/pkg/handlers/response.go (100.0%)</option>
				
				<option value="file5">mail/pkg/handlers/user.go (55.6%)</option>
				
				<option value="file6">mail/pkg/middleware/auth.go (100.0%)</option>
				
				<option value="file7">mail/pkg/session/manager.go (92.3%)</option>
				
				<option value="file8">mail/pkg/session/session.go (100.0%)</option>
				
				<option value="file9">mail/pkg/user/repo.go (87.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "github.com/rs/cors"
        "net/http"

        "mail/pkg/email"
        "mail/pkg/handlers"
        "mail/pkg/session"
        "mail/pkg/user"

        _ "mail/docs"

        "github.com/gorilla/mux"
        httpSwagger "github.com/swaggo/http-swagger/v2"
)

// @title API Mail
// @version 1.0
// @description API server for mail

// @host localhost:8080
// @BasePath /
func main() <span class="cov0" title="0">{
        sessionsManager := session.NewSessionsManager()

        emailRepository := email.NewEmailMemoryRepository()
        userRepository := user.NewInMemoryUserRepository()

        emailHandler := &amp;handlers.EmailHandler{
                EmailRepository: emailRepository,
                Sessions:        sessionsManager,
        }

        userHandler := &amp;handlers.UserHandler{
                UserRepository: userRepository,
                Sessions:       sessionsManager,
        }

        router := mux.NewRouter()
        router.HandleFunc("/api/v1/emails", emailHandler.List).Methods("GET", "OPTIONS")
        router.HandleFunc("/api/v1/email/{id}", emailHandler.GetByID).Methods("GET", "OPTIONS")
        router.HandleFunc("/api/v1/email/add", emailHandler.Add).Methods("POST", "OPTIONS")
        router.HandleFunc("/api/v1/email/update/{id}", emailHandler.Update).Methods("PUT", "OPTIONS")
        router.HandleFunc("/api/v1/email/delete/{id}", emailHandler.Delete).Methods("DELETE", "OPTIONS")

        router.HandleFunc("/api/v1/verify-auth", userHandler.VerifyAuth).Methods("GET", "OPTIONS")
        router.HandleFunc("/api/v1/login", userHandler.Login).Methods("POST", "OPTIONS")
        router.HandleFunc("/api/v1/signup", userHandler.Signup).Methods("POST", "OPTIONS")
        router.HandleFunc("/api/v1/logout", userHandler.Logout).Methods("POST", "OPTIONS")
        router.HandleFunc("/api/v1/get-user", userHandler.GetUserBySession).Methods("GET", "OPTIONS")

        router.PathPrefix("/swagger/").Handler(httpSwagger.WrapHandler)

        c := cors.New(cors.Options{
                AllowedOrigins:   []string{"http://127.0.0.1:8081", "http://89.208.223.140:8081", "http://localhost:8080", "http://localhost:8081", "http://89.208.223.140:8080"},
                AllowedMethods:   []string{http.MethodGet, http.MethodPost, http.MethodDelete, http.MethodPut, http.MethodOptions},
                AllowCredentials: true,
        })

        corsHandler := c.Handler(router)

        port := 8080
        fmt.Printf("The server is running on http://localhost:%d\n", port)
        fmt.Printf("Swagger is running on http://localhost:%d/swagger/index.html\n", port)

        err := http.ListenAndServe(fmt.Sprintf("0.0.0.0:%d", port), corsHandler)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error when starting the server:", err)
        }</span>
        // 89.208.223.140
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/api/v1/email/add": {
            "post": {
                "description": "Add a new email message to the system",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "summary": "Add a new email message",
                "parameters": [
                    {
                        "description": "Email message in JSON format",
                        "name": "email",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/email.Email"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "ID of the added email message",
                        "schema": {
                            "$ref": "#/definitions/handlers.Response"
                        }
                    },
                    "400": {
                        "description": "Bad JSON in request",
                        "schema": {
                            "$ref": "#/definitions/handlers.Response"
                        }
                    },
                    "401": {
                        "description": "Not Authorized",
                        "schema": {
                            "$ref": "#/definitions/handlers.Response"
                        }
                    },
                    "500": {
                        "description": "Failed to add email message",
                        "schema": {
                            "$ref": "#/definitions/handlers.Response"
                        }
                    }
                }
            }
        },
        "/api/v1/email/delete/{id}": {
            "delete": {
                "description": "Delete an email message based on its identifier",
                "produces": [
                    "application/json"
                ],
                "summary": "Delete an email message",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "ID of the email message",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Deletion success status",
                        "schema": {
                            "$ref": "#/definitions/handlers.Response"
                        }
                    },
                    "400": {
                        "description": "Bad id",
                        "schema": {
                            "$ref": "#/definitions/handlers.Response"
                        }
                    },
                    "401": {
                        "description": "Not Authorized",
                        "schema": {
                            "$ref": "#/definitions/handlers.Response"
                        }
                    },
                    "500": {
                        "description": "Failed to delete email message",
                        "schema": {
                            "$ref": "#/definitions/handlers.Response"
                        }
                    }
                }
            }
        },
        "/api/v1/email/update/{id}": {
            "put": {
                "description": "Update an existing email message based on its identifier",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "summary": "Update an email message",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "ID of the email message",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Email message in JSON format",
                        "name": "email",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/email.Email"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Update success status",
                        "schema": {
                            "$ref": "#/definitions/handlers.Response"
                        }
                    },
                    "400": {
                        "description": "Bad id or Bad JSON",
                        "schema": {
                            "$ref": "#/definitions/handlers.Response"
                        }
                    },
                    "401": {
                        "description": "Not Authorized",
                        "schema": {
                            "$ref": "#/definitions/handlers.Response"
                        }
                    },
                    "500": {
                        "description": "Failed to update email message",
                        "schema": {
                            "$ref": "#/definitions/handlers.Response"
                        }
                    }
                }
            }
        },
        "/api/v1/email/{id}": {
            "get": {
                "description": "Get an email message by its unique identifier",
                "produces": [
                    "application/json"
                ],
                "summary": "Get an email message by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "ID of the email message",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Email message data",
                        "schema": {
                            "$ref": "#/definitions/handlers.Response"
                        }
                    },
                    "400": {
                        "description": "Bad id in request",
                        "schema": {
                            "$ref": "#/definitions/handlers.Response"
                        }
                    },
                    "401": {
                        "description": "Not Authorized",
                        "schema": {
                            "$ref": "#/definitions/handlers.Response"
                        }
                    },
                    "404": {
                        "description": "Email not found",
                        "schema": {
                            "$ref": "#/definitions/handlers.Response"
                        }
                    }
                }
            }
        },
        "/api/v1/emails": {
            "get": {
                "description": "Get a list of all email messages",
                "produces": [
                    "application/json"
                ],
                "summary": "Display the list of email messages",
                "responses": {
                    "200": {
                        "description": "List of all email messages",
                        "schema": {
                            "$ref": "#/definitions/handlers.Response"
                        }
                    },
                    "401": {
                        "description": "Not Authorized",
                        "schema": {
                            "$ref": "#/definitions/handlers.Response"
                        }
                    },
                    "404": {
                        "description": "DB error",
                        "schema": {
                            "$ref": "#/definitions/handlers.Response"
                        }
                    },
                    "500": {
                        "description": "JSON encoding error",
                        "schema": {
                            "$ref": "#/definitions/handlers.Response"
                        }
                    }
                }
            }
        },
        "/api/v1/get-user": {
            "get": {
                "description": "Retrieve the user associated with the current session",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Get user by session",
                "responses": {
                    "200": {
                        "description": "User details",
                        "schema": {
                            "$ref": "#/definitions/handlers.Response"
                        }
                    },
                    "401": {
                        "description": "Not Authorized",
                        "schema": {
                            "$ref": "#/definitions/handlers.Response"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/login": {
            "post": {
                "description": "Handles user login.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "User login",
                "parameters": [
                    {
                        "description": "User credentials for login",
                        "name": "credentials",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/user.User"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Login successful",
                        "schema": {
                            "$ref": "#/definitions/handlers.Response"
                        }
                    },
                    "400": {
                        "description": "Invalid request body",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Invalid credentials",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to create session",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/logout": {
            "post": {
                "description": "Handles user logout.",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "User logout",
                "responses": {
                    "200": {
                        "description": "Logout successful",
                        "schema": {
                            "$ref": "#/definitions/handlers.Response"
                        }
                    }
                }
            }
        },
        "/api/v1/signup": {
            "post": {
                "description": "Handles user signup.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "User signup",
                "parameters": [
                    {
                        "description": "New user details for signup",
                        "name": "newUser",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/user.User"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Signup successful",
                        "schema": {
                            "$ref": "#/definitions/handlers.Response"
                        }
                    },
                    "400": {
                        "description": "Invalid request body",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to add user",
                        "schema": {
                            "$ref": "#/definitions/handlers.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/verify-auth": {
            "get": {
                "description": "Verify user authentication using sessions",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Verify user authentication",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/handlers.Response"
                        }
                    },
                    "401": {
                        "description": "Not Authorized",
                        "schema": {
                            "$ref": "#/definitions/handlers.Response"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "email.Email": {
            "type": "object",
            "properties": {
                "dateOfDispatch": {
                    "description": "Date when the email was sent.",
                    "type": "string"
                },
                "deleted": {
                    "description": "Status indicating whether the email has been deleted.",
                    "type": "boolean"
                },
                "draftStatus": {
                    "description": "Status indicating that the email is a draft.",
                    "type": "boolean"
                },
                "id": {
                    "description": "Unique identifier of the email in the database.",
                    "type": "integer"
                },
                "mark": {
                    "description": "A flag, for example, marking the email as a favorite.",
                    "type": "string"
                },
                "photoId": {
                    "description": "Link to the photo attached to the email, if any.",
                    "type": "string"
                },
                "readStatus": {
                    "description": "Status indicating whether the email has been read.",
                    "type": "boolean"
                },
                "replyToEmailId": {
                    "description": "ID of the email to which a reply can be sent.",
                    "type": "integer"
                },
                "text": {
                    "description": "Text body of the email.",
                    "type": "string"
                },
                "topic": {
                    "description": "Subject of the email.",
                    "type": "string"
                }
            }
        },
        "handlers.ErrorResponse": {
            "type": "object",
            "properties": {
                "error": {
                    "type": "string"
                }
            }
        },
        "handlers.Response": {
            "type": "object",
            "properties": {
                "body": {},
                "status": {
                    "type": "integer"
                }
            }
        },
        "user.User": {
            "type": "object",
            "properties": {
                "avatar": {
                    "description": "User's avatar.",
                    "type": "string"
                },
                "id": {
                    "description": "Unique identifier of the user.",
                    "type": "integer"
                },
                "login": {
                    "description": "User's login.",
                    "type": "string"
                },
                "name": {
                    "description": "User's first name.",
                    "type": "string"
                },
                "password": {
                    "description": "User's password.",
                    "type": "string"
                },
                "surname": {
                    "description": "User's last name.",
                    "type": "string"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8080",
        BasePath:         "/",
        Schemes:          []string{},
        Title:            "API Mail",
        Description:      "API server for mail",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package email

import (
        "fmt"
        "sync"
)

// EmailMemoryRepository represents the implementation of EmailRepository using an in-memory storage.
type EmailMemoryRepository struct {
        mu     sync.RWMutex
        emails map[uint64]*Email
}

// NewEmailMemoryRepository creates a new instance of EmailMemoryRepository.
func NewEmailMemoryRepository() *EmailMemoryRepository <span class="cov0" title="0">{
        fakeEmails := FakeEmails
        return &amp;EmailMemoryRepository{
                emails: fakeEmails,
        }
}</span>

// NewEmptyInMemoryEmailRepository creates a new email repository in memory with an empty default email list.
func NewEmptyInMemoryEmailRepository() *EmailMemoryRepository <span class="cov8" title="1">{
        defaultEmails := map[uint64]*Email{}
        return &amp;EmailMemoryRepository{
                emails: defaultEmails,
        }
}</span>

func CreateFakeEmails() *EmailMemoryRepository <span class="cov8" title="1">{
        repo := NewEmptyInMemoryEmailRepository()

        for i := 1; i-1 &lt; len(FakeEmails); i++ </span><span class="cov8" title="1">{
                repo.emails[uint64(i)] = FakeEmails[uint64(i)]
        }</span>
        <span class="cov8" title="1">return repo</span>
}

// GetAll returns all emails from the storage.
func (repository *EmailMemoryRepository) GetAll() ([]*Email, error) <span class="cov8" title="1">{
        repository.mu.RLock()
        defer repository.mu.RUnlock()

        emails := make([]*Email, 0, len(repository.emails))
        for i := 0; i &lt; len(repository.emails); i++ </span><span class="cov8" title="1">{
                emails = append(emails, repository.emails[uint64(i+1)])
        }</span>

        <span class="cov8" title="1">return emails, nil</span>
}

// GetByID returns an email based on its unique identifier.
func (repository *EmailMemoryRepository) GetByID(id uint64) (*Email, error) <span class="cov8" title="1">{
        repository.mu.RLock()
        defer repository.mu.RUnlock()

        email, found := repository.emails[id]
        if !found </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Email with id %d not found", id)
        }</span>

        <span class="cov8" title="1">return email, nil</span>
}

// Add adds a new email to the storage and returns the assigned unique identifier.
func (repository *EmailMemoryRepository) Add(email *Email) (*Email, error) <span class="cov8" title="1">{
        repository.mu.Lock()
        defer repository.mu.Unlock()

        id := uint64(len(repository.emails) + 1)
        email.ID = id
        repository.emails[id] = email

        return repository.emails[id], nil
}</span>

// Update updates the data of an email in the storage based on the provided new email.
func (repository *EmailMemoryRepository) Update(newEmail *Email) (bool, error) <span class="cov8" title="1">{
        repository.mu.Lock()
        defer repository.mu.Unlock()

        existingEmail, found := repository.emails[newEmail.ID]
        if !found </span><span class="cov0" title="0">{
                return false, fmt.Errorf("Email with id %d not found", newEmail.ID)
        }</span>

        <span class="cov8" title="1">existingEmail.Topic = newEmail.Topic
        existingEmail.Text = newEmail.Text
        existingEmail.PhotoID = newEmail.PhotoID
        existingEmail.ReadStatus = newEmail.ReadStatus
        existingEmail.Mark = newEmail.Mark
        existingEmail.Deleted = newEmail.Deleted
        existingEmail.DateOfDispatch = newEmail.DateOfDispatch
        existingEmail.ReplyToEmailID = newEmail.ReplyToEmailID
        existingEmail.DraftStatus = newEmail.DraftStatus

        return true, nil</span>
}

// Delete removes an email from the storage based on its unique identifier.
func (repository *EmailMemoryRepository) Delete(id uint64) (bool, error) <span class="cov8" title="1">{
        repository.mu.Lock()
        defer repository.mu.Unlock()

        _, found := repository.emails[id]
        if !found </span><span class="cov0" title="0">{
                return false, fmt.Errorf("Email with id %d not found", id)
        }</span>

        <span class="cov8" title="1">delete(repository.emails, id)

        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        "encoding/json"
        "fmt"
        "mail/pkg/email"
        "mail/pkg/session"
        "net/http"
        "strconv"

        "github.com/gorilla/mux"
        "github.com/gorilla/schema"
)

// EmailHandler represents the handler for email operations.
type EmailHandler struct {
        EmailRepository email.EmailRepository
        Sessions        *session.SessionsManager
}

// List displays the list of email messages.
// @Summary Display the list of email messages
// @Description Get a list of all email messages
// @Produce json
// @Success 200 {object} Response "List of all email messages"
// @Failure 401 {object} Response "Not Authorized"
// @Failure 404 {object} Response "DB error"
// @Failure 500 {object} Response "JSON encoding error"
// @Router /api/v1/emails [get]
func (h *EmailHandler) List(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        _, err := h.Sessions.Check(r)
        if err != nil </span><span class="cov8" title="1">{
                handleError(w, http.StatusUnauthorized, "Not Authorized")
                return
        }</span>

        <span class="cov8" title="1">emails, err := h.EmailRepository.GetAll()
        if err != nil </span><span class="cov0" title="0">{
                handleError(w, http.StatusNotFound, fmt.Sprintf("DB error: %s", err.Error()))
                return
        }</span>

        <span class="cov8" title="1">handleSuccess(w, http.StatusOK, map[string]interface{}{"emails": emails})</span>
}

// GetByID returns an email message by its ID.
// @Summary Get an email message by ID
// @Description Get an email message by its unique identifier
// @Produce json
// @Param id path integer true "ID of the email message"
// @Success 200 {object} Response "Email message data"
// @Failure 400 {object} Response "Bad id in request"
// @Failure 401 {object} Response "Not Authorized"
// @Failure 404 {object} Response "Email not found"
// @Router /api/v1/email/{id} [get]
func (h *EmailHandler) GetByID(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        _, err := h.Sessions.Check(r)
        if err != nil </span><span class="cov8" title="1">{
                handleError(w, http.StatusUnauthorized, "Not Authorized")
                return
        }</span>

        <span class="cov8" title="1">vars := mux.Vars(r)
        id, err := strconv.ParseUint(vars["id"], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                handleError(w, http.StatusBadRequest, "Bad id in request")
                return
        }</span>

        <span class="cov8" title="1">email, err := h.EmailRepository.GetByID(id)
        if err != nil </span><span class="cov8" title="1">{
                handleError(w, http.StatusNotFound, "Email not found")
                return
        }</span>

        <span class="cov8" title="1">handleSuccess(w, http.StatusOK, map[string]interface{}{"email": email})</span>
}

// Add adds a new email message.
// @Summary Add a new email message
// @Description Add a new email message to the system
// @Accept json
// @Produce json
// @Param email body email.Email true "Email message in JSON format"
// @Success 200 {object} Response "ID of the added email message"
// @Failure 400 {object} Response "Bad JSON in request"
// @Failure 401 {object} Response "Not Authorized"
// @Failure 500 {object} Response "Failed to add email message"
// @Router /api/v1/email/add [post]
func (h *EmailHandler) Add(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        _, err := h.Sessions.Check(r)
        if err != nil </span><span class="cov8" title="1">{
                handleError(w, http.StatusUnauthorized, "Not Authorized")
                return
        }</span>

        <span class="cov8" title="1">var newEmail email.Email
        decoder := schema.NewDecoder()
        decoder.IgnoreUnknownKeys(true)
        err = json.NewDecoder(r.Body).Decode(&amp;newEmail)
        if err != nil </span><span class="cov8" title="1">{
                handleError(w, http.StatusBadRequest, "Bad JSON in request")
                return
        }</span>

        <span class="cov8" title="1">email, err := h.EmailRepository.Add(&amp;newEmail)
        if err != nil </span><span class="cov0" title="0">{
                handleError(w, http.StatusInternalServerError, "Failed to add email message")
                return
        }</span>

        <span class="cov8" title="1">handleSuccess(w, http.StatusOK, map[string]interface{}{"email": email})</span>
}

// Update updates an existing email message.
// @Summary Update an email message
// @Description Update an existing email message based on its identifier
// @Accept json
// @Produce json
// @Param id path integer true "ID of the email message"
// @Param email body email.Email true "Email message in JSON format"
// @Success 200 {object} Response "Update success status"
// @Failure 400 {object} Response "Bad id or Bad JSON"
// @Failure 401 {object} Response "Not Authorized"
// @Failure 500 {object} Response "Failed to update email message"
// @Router /api/v1/email/update/{id} [put]
func (h *EmailHandler) Update(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        _, err := h.Sessions.Check(r)
        if err != nil </span><span class="cov8" title="1">{
                handleError(w, http.StatusUnauthorized, "Not Authorized")
                return
        }</span>

        <span class="cov8" title="1">vars := mux.Vars(r)
        id, err := strconv.ParseUint(vars["id"], 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                handleError(w, http.StatusBadRequest, "Bad id in request")
                return
        }</span>

        <span class="cov8" title="1">var updatedEmail email.Email
        decoder := schema.NewDecoder()
        decoder.IgnoreUnknownKeys(true)
        err = json.NewDecoder(r.Body).Decode(&amp;updatedEmail)
        if err != nil </span><span class="cov8" title="1">{
                handleError(w, http.StatusBadRequest, "Bad JSON in request")
                return
        }</span>
        <span class="cov0" title="0">updatedEmail.ID = id

        ok, err := h.EmailRepository.Update(&amp;updatedEmail)
        if err != nil </span><span class="cov0" title="0">{
                handleError(w, http.StatusInternalServerError, "Failed to update email message")
                return
        }</span>

        <span class="cov0" title="0">handleSuccess(w, http.StatusOK, map[string]interface{}{"Success": ok})</span>
}

// Delete deletes an email message.
// @Summary Delete an email message
// @Description Delete an email message based on its identifier
// @Produce json
// @Param id path integer true "ID of the email message"
// @Success 200 {object} Response "Deletion success status"
// @Failure 400 {object} Response "Bad id"
// @Failure 401 {object} Response "Not Authorized"
// @Failure 500 {object} Response "Failed to delete email message"
// @Router /api/v1/email/delete/{id} [delete]
func (h *EmailHandler) Delete(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        _, err := h.Sessions.Check(r)
        if err != nil </span><span class="cov8" title="1">{
                handleError(w, http.StatusUnauthorized, "Not Authorized")
                return
        }</span>

        <span class="cov8" title="1">vars := mux.Vars(r)
        id, err := strconv.ParseUint(vars["id"], 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                handleError(w, http.StatusBadRequest, "Bad id in request")
                return
        }</span>

        <span class="cov8" title="1">ok, err := h.EmailRepository.Delete(id)
        if err != nil </span><span class="cov0" title="0">{
                handleError(w, http.StatusInternalServerError, "Failed to delete email message")
                return
        }</span>

        <span class="cov8" title="1">handleSuccess(w, http.StatusOK, map[string]interface{}{"Success": ok})</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
)

// Response represents the response format.
type Response struct {
        Status int         `json:"status"`
        Body   interface{} `json:"body"`
}

// ErrorResponse represents the error response format.
type ErrorResponse struct {
        Error string `json:"error"`
}

// handleSuccess is a utility function to handle successful responses uniformly in the API.
func handleSuccess(w http.ResponseWriter, status int, body interface{}) <span class="cov8" title="1">{
        response := Response{
                Status: status,
                Body:   body,
        }
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        json.NewEncoder(w).Encode(response)
}</span>

// handleError is a utility function to handle errors uniformly in the API responses.
func handleError(w http.ResponseWriter, status int, message string) <span class="cov8" title="1">{
        response := Response{
                Status: status,
                Body:   ErrorResponse{Error: message},
        }
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        json.NewEncoder(w).Encode(response)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "strings"

        "mail/pkg/session"
        "mail/pkg/user"
)

// UserHandler handles user-related HTTP requests.
type UserHandler struct {
        UserRepository user.UserRepository
        Sessions       *session.SessionsManager
}

// VerifyAuth verifies user authentication.
// @Summary Verify user authentication
// @Description Verify user authentication using sessions
// @Tags users
// @Produce json
// @Success 200 {object} Response "OK"
// @Failure 401 {object} Response "Not Authorized"
// @Router /api/v1/verify-auth [get]
func (uh *UserHandler) VerifyAuth(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        _, err := uh.Sessions.Check(r)
        if err != nil </span><span class="cov0" title="0">{
                handleError(w, http.StatusUnauthorized, "Not Authorized")
                return
        }</span>

        <span class="cov0" title="0">handleSuccess(w, http.StatusOK, map[string]interface{}{"Success": "OK"})</span>
}

// Login handles user login.
// @Summary User login
// @Description Handles user login.
// @Tags users
// @Accept json
// @Produce json
// @Param credentials body user.User true "User credentials for login"
// @Success 200 {object} Response "Login successful"
// @Failure 400 {object} ErrorResponse "Invalid request body"
// @Failure 401 {object} ErrorResponse "Invalid credentials"
// @Failure 500 {object} ErrorResponse "Failed to create session"
// @Router /api/v1/login [post]
func (uh *UserHandler) Login(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var credentials user.User
        err := json.NewDecoder(r.Body).Decode(&amp;credentials)
        if err != nil </span><span class="cov8" title="1">{
                handleError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov8" title="1">if isEmpty(credentials.Login) || isEmpty(credentials.Password) </span><span class="cov0" title="0">{
                handleError(w, http.StatusInternalServerError, "All fields must be filled in")
                return
        }</span>

        <span class="cov8" title="1">ourUser, err := uh.UserRepository.GetUserByLogin(credentials.Login, credentials.Password)
        if err != nil </span><span class="cov8" title="1">{
                handleError(w, http.StatusUnauthorized, "Login failed")
                return
        }</span>

        <span class="cov8" title="1">_, er := uh.Sessions.Create(w, ourUser.ID)
        if er != nil </span><span class="cov0" title="0">{
                handleError(w, http.StatusInternalServerError, "Failed to create session")
                return
        }</span>

        <span class="cov8" title="1">handleSuccess(w, http.StatusOK, map[string]interface{}{"Success": "Login successful"})</span>
}

// Signup handles user signup.
// @Summary User signup
// @Description Handles user signup.
// @Tags users
// @Accept json
// @Produce json
// @Param newUser body user.User true "New user details for signup"
// @Success 200 {object} Response "Signup successful"
// @Failure 400 {object} ErrorResponse "Invalid request body"
// @Failure 500 {object} ErrorResponse "Failed to add user"
// @Router /api/v1/signup [post]
func (uh *UserHandler) Signup(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var newUser user.User
        err := json.NewDecoder(r.Body).Decode(&amp;newUser)
        if err != nil </span><span class="cov8" title="1">{
                handleError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov8" title="1">if isEmpty(newUser.Name) || isEmpty(newUser.Surname) || isEmpty(newUser.Login) || isEmpty(newUser.Password) </span><span class="cov8" title="1">{
                handleError(w, http.StatusBadRequest, "All fields must be filled in")
        }</span>

        <span class="cov8" title="1">users, _ := uh.UserRepository.GetAll()
        for _, u := range users </span><span class="cov8" title="1">{
                if u.Login == newUser.Login </span><span class="cov0" title="0">{
                        handleError(w, http.StatusBadRequest, "Such a login already exists")
                        return
                }</span>
        }

        <span class="cov8" title="1">_, er := uh.UserRepository.Add(&amp;newUser)
        if er != nil </span><span class="cov0" title="0">{
                handleError(w, http.StatusInternalServerError, "Failed to add user")
        }</span>

        <span class="cov8" title="1">handleSuccess(w, http.StatusOK, map[string]interface{}{"Success": "Signup successful"})</span>
}

// Logout handles user logout.
// @Summary User logout
// @Description Handles user logout.
// @Tags users
// @Produce json
// @Success 200 {object} Response "Logout successful"
// @Router /api/v1/logout [post]
func (uh *UserHandler) Logout(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        err := uh.Sessions.DestroyCurrent(w, r)
        if err != nil </span><span class="cov0" title="0">{
                handleError(w, http.StatusUnauthorized, "Not Authorized")
                return
        }</span>

        <span class="cov8" title="1">handleSuccess(w, http.StatusOK, map[string]interface{}{"Success": "Logout successful"})</span>
}

// GetUserBySession retrieves the user associated with the current session.
// @Summary Get user by session
// @Description Retrieve the user associated with the current session
// @Tags users
// @Produce json
// @Success 200 {object} Response "User details"
// @Failure 401 {object} Response "Not Authorized"
// @Failure 500 {object} ErrorResponse "Internal Server Error"
// @Router /api/v1/get-user [get]
func (uh *UserHandler) GetUserBySession(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sessionUser, err := uh.Sessions.Check(r)
        if err != nil </span><span class="cov0" title="0">{
                handleError(w, http.StatusUnauthorized, "Not Authorized")
                return
        }</span>

        <span class="cov0" title="0">userData, err := uh.UserRepository.GetByID(sessionUser.UserID)
        if err != nil </span><span class="cov0" title="0">{
                handleError(w, http.StatusInternalServerError, "Internal Server Error")
                return
        }</span>

        <span class="cov0" title="0">userJson := user.User{
                Login:    userData.Login,
                Name:     userData.Name,
                Surname:  userData.Surname,
                AvatarId: userData.AvatarId,
        }

        handleSuccess(w, http.StatusOK, map[string]interface{}{"user": userJson})</span>
}

// isEmpty checks if the given string is empty after trimming leading and trailing whitespace.
// Returns true if the string is empty, and false otherwise.
func isEmpty(str string) bool <span class="cov8" title="1">{
        return strings.TrimSpace(str) == ""
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package middleware

import (
        "net/http"
)

// AuthMiddleware is a middleware to check user authentication using cookies.
func AuthMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                cookie, err := r.Cookie("session_id")

                if err != nil || cookie.Value == "" </span><span class="cov8" title="1">{
                        w.Header().Set("Location", "/login")
                        w.WriteHeader(http.StatusFound)
                        return
                }</span>

                <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package session

import (
        "net/http"
        "sync"
        "time"
)

type SessionsManager struct {
        mu   *sync.RWMutex
        data map[string]*Session
}

func NewSessionsManager() *SessionsManager <span class="cov8" title="1">{
        return &amp;SessionsManager{
                data: make(map[string]*Session, 10),
                mu:   &amp;sync.RWMutex{},
        }
}</span>

func (sm *SessionsManager) Check(r *http.Request) (*Session, error) <span class="cov8" title="1">{
        sessionCookie, err := r.Cookie("session_id")
        if err == http.ErrNoCookie </span><span class="cov8" title="1">{
                return nil, ErrNoAuth
        }</span>

        <span class="cov8" title="1">sm.mu.RLock()
        sess, ok := sm.data[sessionCookie.Value]
        sm.mu.RUnlock()

        if !ok </span><span class="cov0" title="0">{
                return nil, ErrNoAuth
        }</span>

        <span class="cov8" title="1">return sess, nil</span>
}

func (sm *SessionsManager) Create(w http.ResponseWriter, userID uint32) (*Session, error) <span class="cov8" title="1">{
        sess := NewSession(userID)

        sm.mu.RLock()
        sm.data[sess.ID] = sess
        sm.mu.RUnlock()

        cookie := &amp;http.Cookie{
                Name:    "session_id",
                Value:   sess.ID,
                Expires: time.Now().Add(90 * 24 * time.Hour),
                Path:    "/",
        }
        http.SetCookie(w, cookie)

        return sess, nil
}</span>

func (sm *SessionsManager) DestroyCurrent(w http.ResponseWriter, r *http.Request) error <span class="cov8" title="1">{
        c, err := r.Cookie("session_id")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">sm.mu.RLock()
        delete(sm.data, c.Value)
        sm.mu.RUnlock()

        cookie := http.Cookie{
                Name:    "session_id",
                Expires: time.Now().AddDate(0, 0, -1),
                Path:    "/",
        }
        http.SetCookie(w, &amp;cookie)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package session

import (
        "context"
        "crypto/rand"
        "errors"
        "fmt"
)

type Session struct {
        ID     string
        UserID uint32
}

func NewSession(userID uint32) *Session <span class="cov8" title="1">{
        randID := make([]byte, 16)
        rand.Read(randID)

        return &amp;Session{
                ID:     fmt.Sprintf("%x", randID),
                UserID: userID,
        }
}</span>

var (
        ErrNoAuth = errors.New("No session found")
)

type sessionKey string

var SessionKey sessionKey = "sessionKey"

func SessionFromContext(ctx context.Context) (*Session, error) <span class="cov8" title="1">{
        sess, ok := ctx.Value(SessionKey).(*Session)
        if !ok || sess == nil </span><span class="cov8" title="1">{
                return nil, ErrNoAuth
        }</span>

        <span class="cov8" title="1">return sess, nil</span>
}

func ContextWithSession(ctx context.Context, sess *Session) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, SessionKey, sess)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package user

import (
        "fmt"
        "golang.org/x/crypto/bcrypt"
        "sync"
)

// UserMemoryRepository is an in-memory implementation of UserRepository.
type UserMemoryRepository struct {
        mutex sync.RWMutex
        users map[uint32]*User
}

// NewUserMemoryRepository creates a new instance of UserMemoryRepository.
func NewInMemoryUserRepository() *UserMemoryRepository <span class="cov8" title="1">{
        return &amp;UserMemoryRepository{
                users: FakeUsers,
        }
}</span>

// NewEmptyInMemoryUserRepository creates a new user repository in memory with an empty default user list.
func NewEmptyInMemoryUserRepository() *UserMemoryRepository <span class="cov8" title="1">{
        defaultUsers := map[uint32]*User{}
        return &amp;UserMemoryRepository{
                users: defaultUsers,
        }
}</span>

// HashPassword takes a plaintext password as input and returns its bcrypt hash.
func HashPassword(password string) (string, bool) <span class="cov8" title="1">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov8" title="1">hashedPassword := string(bytes)
        fmt.Println("Hashed Password:", hashedPassword)

        return string(bytes), true</span>
}

// CheckPasswordHash compares a password with a hash and returns true if they match, otherwise false.
func CheckPasswordHash(password, hash string) bool <span class="cov8" title="1">{
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
        return err == nil
}</span>

// ComparingUserObjects compares two user objects by comparing their IDs, names, surnames, logins, and password hashes.
// If all fields match, the function returns true, otherwise false.
func ComparingUserObjects(object1, object2 User) bool <span class="cov0" title="0">{
        if object1.ID == object2.ID &amp;&amp;
                object1.Name == object2.Name &amp;&amp;
                object1.Surname == object2.Surname &amp;&amp;
                object1.Login == object2.Login &amp;&amp;
                CheckPasswordHash(object2.Password, object1.Password) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

// GetAll returns all users from the storage.
func (repo *UserMemoryRepository) GetAll() ([]*User, error) <span class="cov8" title="1">{
        repo.mutex.RLock()
        defer repo.mutex.RUnlock()

        users := make([]*User, 0, len(repo.users))
        for i := 0; i &lt; len(repo.users); i++ </span><span class="cov8" title="1">{
                users = append(users, repo.users[uint32(i+1)])
        }</span>

        <span class="cov8" title="1">return users, nil</span>
}

// GetByID returns the user by its unique identifier.
func (repo *UserMemoryRepository) GetByID(id uint32) (*User, error) <span class="cov8" title="1">{
        repo.mutex.RLock()
        defer repo.mutex.RUnlock()

        user, exists := repo.users[id]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("User with id %d not found", id)
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

// GetUserByLogin returns the user by login.
func (repo *UserMemoryRepository) GetUserByLogin(login string, password string) (*User, error) <span class="cov8" title="1">{
        repo.mutex.RLock()
        defer repo.mutex.RUnlock()

        for _, u := range repo.users </span><span class="cov8" title="1">{
                if u.Login == login </span><span class="cov8" title="1">{
                        if CheckPasswordHash(password, u.Password) </span><span class="cov8" title="1">{
                                return u, nil
                        }</span> else<span class="cov8" title="1"> {
                                return nil, fmt.Errorf("User with the username %s was not found", login)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil, fmt.Errorf("User with the username %s was not found", login)</span>
}

// Add adds a new user to the storage and returns its assigned unique identifier.
func (repo *UserMemoryRepository) Add(user *User) (uint32, error) <span class="cov8" title="1">{
        repo.mutex.Lock()
        defer repo.mutex.Unlock()

        userID := uint32(len(repo.users) + 1)
        user.ID = userID
        var err bool
        user.Password, err = HashPassword(user.Password)
        if err == false </span><span class="cov0" title="0">{
                return userID, fmt.Errorf("Operation failed")
        }</span>
        <span class="cov8" title="1">repo.users[userID] = user

        return userID, nil</span>
}

// Update updates the information of a user in the storage based on the provided new user.
func (repo *UserMemoryRepository) Update(newUser *User) (bool, error) <span class="cov8" title="1">{
        repo.mutex.Lock()
        defer repo.mutex.Unlock()

        _, exists := repo.users[newUser.ID]
        if !exists </span><span class="cov0" title="0">{
                return false, fmt.Errorf("User with id %d not found", newUser.ID)
        }</span>

        <span class="cov8" title="1">repo.users[newUser.ID] = newUser

        return true, nil</span>
}

// Delete removes the user from the storage by its unique identifier.
func (repo *UserMemoryRepository) Delete(id uint32) (bool, error) <span class="cov8" title="1">{
        repo.mutex.Lock()
        defer repo.mutex.Unlock()

        _, exists := repo.users[id]
        if !exists </span><span class="cov0" title="0">{
                return false, fmt.Errorf("User with id %d not found", id)
        }</span>

        <span class="cov8" title="1">delete(repo.users, id)

        return true, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
