**Домашнее задание 3 команды Refugio (почта)**

В качестве основной сущности мы выбрали объект письма. Он представляет основную бизнес ценность нашего приложения.
Инструментом для проведения нагрузочного тестирования мы выбрали https://github.com/wg/wrk.

**Выполнение работы.**

1. Для создания 100 000 сущностей мы использовали API endpoint https://mailhub.su/api/v1/email/send, который добавляет письмо в нашу базу данных.
Скрипт lua:
```
-- Импортировать необходимые библиотеки
local wrk = require "wrk"

wrk.method = "POST"
wrk.body = '{"topic": "WRK","text": "WRK_Test","readStatus": false,"mark": false,"replyToEmailId": 0,"draftStatus": false,"spamStatus": false,"senderEmail": "senderWrk@mailhub.su","recipientEmail": "wrk@mailhub.su"}'
wrk.headers["Content-Type"] = "application/json"
wrk.headers["X-Csrf-Token"] = "3b718de1065efe9c8e578ea98452bea8"
wrk.headers["Cookie"] = "session_id=dd001c65474c2617ef0be801e1439336"

-- Указать общее количество запросов
wrk.requests = 100000

-- Настроить параметры потоков
wrk.thread = function()
    -- Указать, что хотим отправить 1000 запросов на каждый поток
    wrk.connections = 10 -- Количество одновременных подключений на поток
    wrk.duration = "1000s" -- Длительность тестирования на поток
    wrk.requests = 20000 -- Количество запросов на поток
end
```
> Команда терминала: ```wrk -t5 -c100 -d2550s -s wrk_send.lua https://mailhub.su/api/v1/email/send```
42 минут, 5 потоков и 100 соединений

Вывод программы:
```
Running 42m test @ https://mailhub.su/api/v1/email/send
    5 threads and 100 connections
    Thread Stats   Avg      Stdev     Max   +/- Stdev
        Latency   297.17ms  267.41ms   1.97s    85.03%
        Req/Sec    11.04      7.30    50.00     56.56%
    100000 requests in 42.50m, 47.78MB read
Requests/sec:     48.90
Transfer/sec:     19.19KB
```
2. Документация результатов и анализ значений:

Latency и Req/Sec показывают параметры функции Гаусса

Requests/sec "RPC" (запросы в секунду): показатель составляет 48,90, что можно считать приемлемым для нашего приложения, но не очень высоким значением.

Transfer/sec (скорость передачи данных): показатель составляет 19,19 КБ/с, что является довольно низким значением.


3. Нагрузочное тестирование API endpoint’а https://mailhub.su/api/v1/email/{id}, который читает письмо по id.

Скрипт lua:
```
-- Импортировать необходимые библиотеки
local wrk = require "wrk"

wrk.method = "GET"
wrk.headers["X-Csrf-Token"] = "3b718de1065efe9c8e578ea98452bea8"
wrk.headers["Cookie"] = "session_id=dd001c65474c2617ef0be801e1439336"

 -- Указать общее количество запросов
 wrk.requests = 100000

 -- Настроить параметры потоков
 wrk.thread = function()
     -- Указать, что хотим отправить 1000 запросов на каждый поток
     wrk.connections = 400 -- Количество одновременных подключений на поток
     wrk.duration = "1000s" -- Длительность тестирования на поток
     wrk.requests = 20000 -- Количество запросов на поток
 end
```
> Команда терминала: ```wrk -t5 -c100 -d1500s -s wrk_get_id.lua https://mailhub.su/api/v1/email/90000```
25 минут, 5 потоков и 100 соединений

Вывод программы:
```
Running 25m test @ https://mailhub.su/api/v1/email/90000
    5 threads and 100 connections
    Thread Stats   Avg      Stdev     Max   +/- Stdev
        Latency    438.37ms   407.96ms   2.00s    61.10%
        Req/Sec    11.88      7.85    90.00     64.37%
    100000 requests in 25.00m, 82.37MB read
Requests/sec:     41.31
Transfer/sec:     56.22KB
```
4. Документация результатов и анализ значений:

Requests/sec "RPC" (запросы в секунду): показатель составляет 41.31, что можно считать приемлемым для нашего приложения, но не очень высоким значением.

Transfer/sec (скорость передачи данных): показатель составляет 56.22 КБ/с, что является довольно низким значением.

Тому что показатели Latency и RPC endpoint'a get_id хуже чем у endpoint'a send есть объяснение. 
При get_id запросе мы делаем на 2 запроса в базу больше чем при добавлении письма, из-за этого возможна просадка по производительности.

5. Как это можно соптимизировать:
- К примеру мы можем отказаться от метода CheckLogin, который показывает, что пользователь тот за кого себя выдаёт. Это не повлияет на безопасность, а при попытке украсть данные злоумышленнику не будет ничего возвращаться. 
- Также мы используем один запрос на получение тела письма, а второй для получения файлов письма. В качестве оптимизации можно попробовать заменить эти два запроса, на единственный для получения полной информации о письме.